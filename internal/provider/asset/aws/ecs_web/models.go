package ecsweb

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	cac "github.com/aptible/cloud-api-clients/clients/go"
	"github.com/aptible/terraform-provider-aptible-iaas/internal/client"
)

var resourceTypeName = "_aws_ecs_web"
var resourceDescription = "ECS web resource"

type Env struct {
	SecretArn     types.String `tfsdk:"secret_arn" json:"secret_arn"`
	SecretJsonKey types.String `tfsdk:"secret_json_key" json:"secret_json_key"`
}

type EnvJson struct {
	EnvVar        string `json:"environment_variable"`
	SecretArn     string `json:"secret_arn"`
	SecretJsonKey string `json:"secret_json_key"`
}

// TODO - autogenerated
type ResourceModel struct {
	Id             types.String `tfsdk:"id" json:"id"`
	AssetVersion   types.String `tfsdk:"asset_version" json:"asset_version"`
	EnvironmentId  types.String `tfsdk:"environment_id" json:"environment_id"`
	OrganizationId types.String `tfsdk:"organization_id" json:"organization_id"`
	Status         types.String `tfsdk:"status" json:"status"`

	VpcName            types.String   `tfsdk:"vpc_name" json:"vpc_name"`
	Name               types.String   `tfsdk:"name" json:"name"`
	IsPublic           types.Bool     `tfsdk:"is_public" json:"is_public"`
	ContainerName      types.String   `tfsdk:"container_name" json:"container_name"`
	ContainerPort      types.Number   `tfsdk:"container_port" json:"container_port"`
	ContainerImage     types.String   `tfsdk:"container_image" json:"container_image"`
	ContainerCommand   []types.String `tfsdk:"container_command" json:"container_command"`
	EnvironmentSecrets map[string]Env `tfsdk:"environment_secrets" json:"environment_secrets"`
	LbCertArn          types.String   `tfsdk:"lb_cert_arn" json:"lb_cert_arn"`
	LbCertDomain       types.String   `tfsdk:"lb_cert_domain" json:"lb_cert_domain"`
	ConnectsTo         []types.String `tfsdk:"connects_to"`
}

var AssetSchema = map[string]tfsdk.Attribute{
	"id": {
		Description: "A valid asset id",
		Type:        types.StringType,
		Computed:    true,
	},
	"status": {
		Type:     types.StringType,
		Computed: true,
	},

	"environment_id": {
		Description: "A valid environment id",
		Type:        types.StringType,
		Required:    true,
	},
	"organization_id": {
		Description: "A valid organization id",
		Type:        types.StringType,
		Required:    true,
	},
	"vpc_name": {
		Description: "A valid vpc name",
		Type:        types.StringType,
		Required:    true,
	},
	"asset_version": {
		Type:     types.StringType,
		Required: true,
	},
	"name": {
		Type:     types.StringType,
		Required: true,
	},
	"is_public": {
		Type:     types.BoolType,
		Required: true,
	},
	"lb_cert_arn": {
		Type:     types.StringType,
		Required: true,
	},
	"lb_cert_domain": {
		Type:     types.StringType,
		Required: true,
	},
	"container_name": {
		Type:     types.StringType,
		Required: true,
	},
	"container_image": {
		Type:     types.StringType,
		Required: true,
	},
	"container_port": {
		Type:     types.NumberType,
		Required: true,
	},
	"container_command": {
		Type:     types.ListType{ElemType: types.StringType},
		Required: true,
	},
	"connects_to": {
		Type:     types.ListType{ElemType: types.StringType},
		Optional: true,
	},
	"environment_secrets": {
		Required: true,
		Attributes: tfsdk.MapNestedAttributes(map[string]tfsdk.Attribute{
			"secret_arn": {
				Type:     types.StringType,
				Required: true,
			},
			"secret_json_key": {
				Type:     types.StringType,
				Required: true,
			},
		}),
	},
}

func planToAssetInput(ctx context.Context, plan ResourceModel) (cac.AssetInput, error) {
	// TODO HACK: https://aptible.slack.com/archives/C03C2STPTDX/p1664478414991299
	dd := strings.SplitN(plan.LbCertDomain.Value, ".", 2)

	cmd := []string{}
	for _, c := range plan.ContainerCommand {
		cmd = append(cmd, c.Value)
	}

	secrets := []EnvJson{}
	for k, v := range plan.EnvironmentSecrets {
		secrets = append(secrets, EnvJson{
			EnvVar:        k,
			SecretArn:     v.SecretArn.Value,
			SecretJsonKey: v.SecretJsonKey.Value,
		})
	}

	params := map[string]interface{}{
		"vpc_name":            plan.VpcName.Value,
		"name":                plan.Name.Value,
		"is_public":           plan.IsPublic.Value,
		"lb_cert_arn":         plan.LbCertArn.Value,
		"lb_cert_domain":      dd[1],
		"lb_cert_subdomain":   dd[0],
		"container_name":      plan.ContainerName.Value,
		"container_image":     plan.ContainerImage.Value,
		"container_port":      plan.ContainerPort.Value,
		"container_command":   cmd,
		"environment_secrets": secrets,
	}

	input := cac.AssetInput{
		Asset:           client.CompileAsset("aws", "ecs_web_service", plan.AssetVersion.Value),
		AssetVersion:    plan.AssetVersion.Value,
		AssetParameters: params,
	}

	if len(plan.ConnectsTo) > 0 {
		connect := []string{}
		for _, c := range plan.ConnectsTo {
			connect = append(connect, c.Value)
		}
		input.ConnectsTo = connect
	}

	return input, nil
}

func assetOutputToPlan(ctx context.Context, output *cac.AssetOutput) (*ResourceModel, error) {
	cmd := []types.String{}
	cmdList := output.CurrentAssetParameters.Data["container_command"].([]interface{})
	for _, c := range cmdList {
		cmd = append(cmd, types.String{Value: c.(string)})
	}

	connect := []types.String{}
	connectList := output.ConnectsTo
	for _, c := range connectList {
		connect = append(connect, types.String{Value: c})
	}

	// TODO: figure out how to not need an intermediate struct for marshal/unmarshal
	secretsJson := []EnvJson{}
	bts, err := json.Marshal(output.CurrentAssetParameters.Data["environment_secrets"])
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(bts, &secretsJson)
	if err != nil {
		return nil, err
	}

	secrets := map[string]Env{}
	for _, v := range secretsJson {
		secrets[v.EnvVar] = Env{
			SecretArn:     types.String{Value: v.SecretArn},
			SecretJsonKey: types.String{Value: v.SecretJsonKey},
		}
	}

	port := output.CurrentAssetParameters.Data["container_port"].(float64)

	// TODO: HACK
	domain := fmt.Sprintf("%s.%s",
		output.CurrentAssetParameters.Data["lb_cert_subdomain"].(string),
		output.CurrentAssetParameters.Data["lb_cert_domain"].(string),
	)

	model := &ResourceModel{
		Id:                 types.String{Value: output.Id},
		AssetVersion:       types.String{Value: output.AssetVersion},
		EnvironmentId:      types.String{Value: output.Environment.Id},
		OrganizationId:     types.String{Value: output.Environment.Organization.Id},
		Status:             types.String{Value: string(output.Status)},
		VpcName:            types.String{Value: output.CurrentAssetParameters.Data["vpc_name"].(string)},
		Name:               types.String{Value: output.CurrentAssetParameters.Data["name"].(string)},
		LbCertArn:          types.String{Value: output.CurrentAssetParameters.Data["lb_cert_arn"].(string)},
		LbCertDomain:       types.String{Value: domain},
		IsPublic:           types.Bool{Value: output.CurrentAssetParameters.Data["is_public"].(bool)},
		ContainerName:      types.String{Value: output.CurrentAssetParameters.Data["container_name"].(string)},
		ContainerPort:      types.Number{Value: big.NewFloat(port)},
		ContainerImage:     types.String{Value: output.CurrentAssetParameters.Data["container_image"].(string)},
		ContainerCommand:   cmd,
		ConnectsTo:         connect,
		EnvironmentSecrets: secrets,
	}

	return model, nil
}
