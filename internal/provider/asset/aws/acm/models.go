package acm

import (
	"context"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	cac "github.com/aptible/cloud-api-clients/clients/go"
	"github.com/aptible/terraform-provider-aptible-iaas/internal/client"
)

var resourceTypeName = "_aws_acm"
var resourceDescription = "ACM Certificate resource"

type DnsValidationRecordJson struct {
	DomainName  string `json:"domain_name"`
	RecordName  string `json:"resource_record_name"`
	RecordType  string `json:"resource_record_type"`
	RecordValue string `json:"resource_record_value"`
}

type DnsValidationRecord struct {
	DomainName  types.String `tfsdk:"domain_name"`
	RecordName  types.String `tfsdk:"resource_record_name"`
	RecordType  types.String `tfsdk:"resource_record_type"`
	RecordValue types.String `tfsdk:"resource_record_value"`
}

// TODO - autogenerated
type ResourceModel struct {
	Id             types.String `tfsdk:"id" json:"id"`
	AssetVersion   types.String `tfsdk:"asset_version" json:"asset_version"`
	EnvironmentId  types.String `tfsdk:"environment_id" json:"environment_id"`
	OrganizationId types.String `tfsdk:"organization_id" json:"organization_id"`
	Status         types.String `tfsdk:"status" json:"status"`

	Fqdn                    types.String `tfsdk:"fqdn" json:"fqdn"`
	ValidationMethod        types.String `tfsdk:"validation_method" json:"validation_method"`
	Arn                     types.String `tfsdk:"arn" json:"arn"`
	DomainValidationRecords types.List   `tfsdk:"domain_validation_records"`
}

var AssetSchema = map[string]tfsdk.Attribute{
	"id": {
		Description: "A valid asset id",
		Type:        types.StringType,
		Computed:    true,
	},
	"status": {
		Type:     types.StringType,
		Computed: true,
	},

	"environment_id": {
		Description: "A valid environment id",
		Type:        types.StringType,
		Required:    true,
	},
	"organization_id": {
		Description: "A valid organization id",
		Type:        types.StringType,
		Required:    true,
	},
	"asset_version": {
		Type:     types.StringType,
		Required: true,
	},
	"fqdn": {
		Type:     types.StringType,
		Required: true,
	},
	"validation_method": {
		Description: "A valid validation method",
		Type:        types.StringType,
		Required:    true,
	},
	"arn": {
		Computed: true,
		Type:     types.StringType,
	},
	"domain_validation_records": {
		Computed: true,
		Optional: true,
		Attributes: tfsdk.ListNestedAttributes(map[string]tfsdk.Attribute{
			"domain_name": {
				Type:     types.StringType,
				Computed: true,
				Optional: true,
			},
			"resource_record_name": {
				Type:     types.StringType,
				Computed: true,
				Optional: true,
			},
			"resource_record_type": {
				Type:     types.StringType,
				Computed: true,
				Optional: true,
			},
			"resource_record_value": {
				Type:     types.StringType,
				Computed: true,
				Optional: true,
			},
		}),
	},
}

func planToAssetInput(ctx context.Context, plan ResourceModel) (cac.AssetInput, error) {
	input := cac.AssetInput{
		Asset:        client.CompileAsset("aws", "acm_certificate", plan.AssetVersion.Value),
		AssetVersion: plan.AssetVersion.Value,
		AssetParameters: map[string]interface{}{
			"fqdn":              plan.Fqdn.Value,
			"validation_method": plan.ValidationMethod.Value,
		},
	}

	return input, nil
}

type DnsData struct {
	Data []DnsValidationRecordJson `json:"data"`
}

func assetOutputToPlan(ctx context.Context, plan ResourceModel, output *cac.AssetOutput) (*ResourceModel, error) {
	outputs := *output.Outputs

	mapper := map[string]attr.Type{
		"domain_name":           types.StringType,
		"resource_record_name":  types.StringType,
		"resource_record_type":  types.StringType,
		"resource_record_value": types.StringType,
	}

	records := []attr.Value{}
	if recs, ok := outputs["dns_validation_records"]; ok {
		recordsJson := DnsData{Data: []DnsValidationRecordJson{}}
		bts, err := json.Marshal(recs)
		if err != nil {
			return nil, err
		}
		err = json.Unmarshal(bts, &recordsJson)
		if err != nil {
			return nil, err
		}

		for _, record := range recordsJson.Data {
			records = append(records, types.Object{
				AttrTypes: mapper,
				Attrs: map[string]attr.Value{
					"domain_name":           types.String{Value: record.DomainName},
					"resource_record_name":  types.String{Value: record.RecordName},
					"resource_record_type":  types.String{Value: record.RecordType},
					"resource_record_value": types.String{Value: record.RecordValue},
				},
			})
		}
	}

	arnRaw := outputs["acm_certificate_arn"].Data
	arn := ""
	switch v := arnRaw.(type) {
	case string:
		arn = v
	default:
		arn = ""
	}

	model := &ResourceModel{
		Id:                      types.String{Value: output.Id},
		AssetVersion:            types.String{Value: output.AssetVersion},
		EnvironmentId:           types.String{Value: output.Environment.Id},
		OrganizationId:          types.String{Value: output.Environment.Organization.Id},
		Status:                  types.String{Value: string(output.Status)},
		Fqdn:                    types.String{Value: output.CurrentAssetParameters.Data["fqdn"].(string)},
		ValidationMethod:        types.String{Value: output.CurrentAssetParameters.Data["validation_method"].(string)},
		Arn:                     types.String{Value: arn},
		DomainValidationRecords: types.List{Elems: records, ElemType: types.ObjectType{AttrTypes: mapper}},
	}

	return model, nil
}
